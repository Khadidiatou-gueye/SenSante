const express = require("express")
const mysql = require("mysql2/promise")
const bcrypt = require("bcryptjs") // Utilisation de bcryptjs pour √©viter les probl√®mes Windows
const jwt = require("jsonwebtoken")
const cors = require("cors")
const path = require("path")

const app = express()
const PORT = 3000
const JWT_SECRET = "sensante_secret_key_2024"

// ================================
// CONFIGURATION ET MIDDLEWARE
// ================================

app.use(cors())
app.use(express.json())
app.use(express.static("public"))

// Configuration de la base de donn√©es
const configBD = {
  host: "localhost",
  user: "root",
  password: "passer",
  database: "sensante",
}

// Variable globale pour la connexion
let connexionBD

// ================================
// FONCTIONS UTILITAIRES
// ================================

// Connexion √† la base de donn√©es
async function connecterBD() {
  try {
    connexionBD = await mysql.createConnection(configBD)
    console.log("‚úÖ Connexion √† MySQL r√©ussie")

    // V√©rifier et cr√©er la colonne role si n√©cessaire
    await verifierStructureBD()
  } catch (erreur) {
    console.error("‚ùå Erreur de connexion √† MySQL:", erreur)
    process.exit(1)
  }
}

// V√©rifier la structure de la base de donn√©es
async function verifierStructureBD() {
  try {
    // V√©rifier si la colonne role existe
    const [colonnes] = await connexionBD.execute("SHOW COLUMNS FROM medecins LIKE 'role'")

    if (colonnes.length === 0) {
      console.log("üîß Ajout de la colonne 'role' √† la table medecins...")
      await connexionBD.execute("ALTER TABLE medecins ADD COLUMN role VARCHAR(20) DEFAULT 'medecin'")
      console.log("‚úÖ Colonne 'role' ajout√©e")
    }
  } catch (erreur) {
    console.error("‚ö†Ô∏è Erreur lors de la v√©rification de la structure:", erreur)
  }
}

// Fonction d'audit - enregistre toutes les actions importantes
async function enregistrerAudit(action, utilisateurId, details) {
  try {
    await connexionBD.execute(
      "INSERT INTO audit (action, utilisateur_id, details, date_action) VALUES (?, ?, ?, NOW())",
      [action, utilisateurId, JSON.stringify(details)],
    )
  } catch (erreur) {
    console.error("Erreur lors de l'enregistrement d'audit:", erreur)
  }
}

// ================================
// MIDDLEWARE D'AUTHENTIFICATION
// ================================

// V√©rifier le token JWT
function verifierToken(req, res, next) {
  const token = req.headers.authorization?.split(" ")[1]

  if (!token) {
    return res.status(401).json({ erreur: "Token manquant" })
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET)
    req.utilisateur = decoded
    next()
  } catch (erreur) {
    return res.status(401).json({ erreur: "Token invalide" })
  }
}

// V√©rifier si l'utilisateur est administrateur
function verifierAdmin(req, res, next) {
  if (req.utilisateur.role !== "admin") {
    return res.status(403).json({ erreur: "Acc√®s r√©serv√© aux administrateurs" })
  }
  next()
}

// ================================
// ROUTES D'AUTHENTIFICATION
// ================================

// Route de connexion
app.post("/api/connexion", async (req, res) => {
  try {
    const { email, motDePasse } = req.body

    console.log(`üîê Tentative de connexion pour: ${email}`)

    // Rechercher l'utilisateur par email
    const [utilisateurs] = await connexionBD.execute("SELECT * FROM medecins WHERE email = ?", [email])

    if (utilisateurs.length === 0) {
      console.log(`‚ùå Utilisateur non trouv√©: ${email}`)
      await enregistrerAudit("TENTATIVE_CONNEXION_ECHEC", null, { email, raison: "utilisateur_inexistant" })
      return res.status(401).json({ erreur: "Identifiants invalides" })
    }

    const utilisateur = utilisateurs[0]
    console.log(`üë§ Utilisateur trouv√©: ${utilisateur.nom} ${utilisateur.prenom} (${utilisateur.role || "medecin"})`)

    // V√©rifier le mot de passe
    const motDePasseValide = await bcrypt.compare(motDePasse, utilisateur.mot_de_passe)

    if (!motDePasseValide) {
      console.log(`‚ùå Mot de passe invalide pour: ${email}`)
      await enregistrerAudit("TENTATIVE_CONNEXION_ECHEC", utilisateur.id, { email, raison: "mot_de_passe_invalide" })
      return res.status(401).json({ erreur: "Identifiants invalides" })
    }

    // Cr√©er le token JWT
    const token = jwt.sign(
      {
        id: utilisateur.id,
        email: utilisateur.email,
        nom: utilisateur.nom,
        prenom: utilisateur.prenom,
        role: utilisateur.role || "medecin",
        site_id: utilisateur.site_id,
      },
      JWT_SECRET,
      { expiresIn: "8h" },
    )

    // Enregistrer la connexion r√©ussie
    await enregistrerAudit("CONNEXION_REUSSIE", utilisateur.id, { email, role: utilisateur.role || "medecin" })

    console.log(`‚úÖ Connexion r√©ussie pour: ${email} (${utilisateur.role || "medecin"})`)

    // R√©ponse avec le token et les infos utilisateur
    res.json({
      token,
      utilisateur: {
        id: utilisateur.id,
        nom: utilisateur.nom,
        prenom: utilisateur.prenom,
        email: utilisateur.email,
        role: utilisateur.role || "medecin",
        site_id: utilisateur.site_id,
      },
    })
  } catch (erreur) {
    console.error("Erreur lors de la connexion:", erreur)
    res.status(500).json({ erreur: "Erreur serveur" })
  }
})

// ================================
// ROUTES DASHBOARD
// ================================

// Dashboard avec gestion des r√¥les
app.get("/api/dashboard", verifierToken, async (req, res) => {
  try {
    console.log(`üìä Chargement dashboard pour: ${req.utilisateur.email} (${req.utilisateur.role})`)

    if (req.utilisateur.role === "admin") {
      // Dashboard admin - statistiques globales
      const [statsPatients] = await connexionBD.execute("SELECT COUNT(*) as total_patients FROM patients")

      const [statsConsultations] = await connexionBD.execute(
        "SELECT COUNT(*) as total_consultations FROM consultations",
      )

      const [statsMedecins] = await connexionBD.execute(
        "SELECT COUNT(*) as total_medecins FROM medecins WHERE role = 'medecin'",
      )

      const [statsSites] = await connexionBD.execute("SELECT COUNT(*) as total_sites FROM sites")

      // Consultations r√©centes (toutes)
      const [consultationsRecentes] = await connexionBD.execute(
        `SELECT c.*, p.nom as nom_patient, p.prenom as prenom_patient, 
                m.nom as nom_medecin, m.prenom as prenom_medecin
         FROM consultations c 
         JOIN patients p ON c.patient_id = p.id 
         JOIN medecins m ON c.medecin_id = m.id
         ORDER BY c.date_consultation DESC 
         LIMIT 10`,
      )

      await enregistrerAudit("CONSULTATION_DASHBOARD_ADMIN", req.utilisateur.id, {
        total_patients: statsPatients[0].total_patients,
        total_consultations: statsConsultations[0].total_consultations,
      })

      res.json({
        type: "admin",
        statistiques: {
          total_patients: statsPatients[0].total_patients,
          total_consultations: statsConsultations[0].total_consultations,
          total_medecins: statsMedecins[0].total_medecins,
          total_sites: statsSites[0].total_sites,
        },
        consultations_recentes: consultationsRecentes,
      })
    } else {
      // Dashboard m√©decin - statistiques personnelles
      const [statsPatientsTotal] = await connexionBD.execute(
        "SELECT COUNT(*) as total_patients_site FROM patients WHERE site_id = ?",
        [req.utilisateur.site_id],
      )

      const [statsConsultationsMedecin] = await connexionBD.execute(
        `SELECT COUNT(*) as total_consultations_medecin 
         FROM consultations c 
         JOIN patients p ON c.patient_id = p.id 
         WHERE p.site_id = ? AND c.medecin_id = ?`,
        [req.utilisateur.site_id, req.utilisateur.id],
      )

      const [statsPatientsConsultes] = await connexionBD.execute(
        `SELECT COUNT(DISTINCT c.patient_id) as patients_consultes 
         FROM consultations c 
         JOIN patients p ON c.patient_id = p.id 
         WHERE p.site_id = ? AND c.medecin_id = ?`,
        [req.utilisateur.site_id, req.utilisateur.id],
      )

      const [consultationsRecentes] = await connexionBD.execute(
        `SELECT c.*, p.nom as nom_patient, p.prenom as prenom_patient 
         FROM consultations c 
         JOIN patients p ON c.patient_id = p.id 
         WHERE p.site_id = ? AND c.medecin_id = ?
         ORDER BY c.date_consultation DESC 
         LIMIT 5`,
        [req.utilisateur.site_id, req.utilisateur.id],
      )

      const [consultationsSemaine] = await connexionBD.execute(
        `SELECT COUNT(*) as consultations_semaine 
         FROM consultations c 
         JOIN patients p ON c.patient_id = p.id 
         WHERE p.site_id = ? AND c.medecin_id = ? 
         AND c.date_consultation >= DATE_SUB(NOW(), INTERVAL 7 DAY)`,
        [req.utilisateur.site_id, req.utilisateur.id],
      )

      await enregistrerAudit("CONSULTATION_DASHBOARD_MEDECIN", req.utilisateur.id, {
        total_patients_site: statsPatientsTotal[0].total_patients_site,
        total_consultations_medecin: statsConsultationsMedecin[0].total_consultations_medecin,
        patients_consultes: statsPatientsConsultes[0].patients_consultes,
      })

      res.json({
        type: "medecin",
        statistiques: {
          total_patients_site: statsPatientsTotal[0].total_patients_site,
          total_consultations_medecin: statsConsultationsMedecin[0].total_consultations_medecin,
          patients_consultes: statsPatientsConsultes[0].patients_consultes,
          consultations_semaine: consultationsSemaine[0].consultations_semaine,
        },
        consultations_recentes: consultationsRecentes,
      })
    }
  } catch (erreur) {
    console.error("Erreur lors de la r√©cup√©ration du dashboard:", erreur)
    res.status(500).json({ erreur: "Erreur serveur" })
  }
})

// ================================
// ROUTES PATIENTS
// ================================

// Lister tous les patients (admin voit tout, m√©decin voit son site)
app.get("/api/patients", verifierToken, async (req, res) => {
  try {
    let query, params

    if (req.utilisateur.role === "admin") {
      query = "SELECT p.*, s.nom as nom_site FROM patients p JOIN sites s ON p.site_id = s.id ORDER BY p.nom, p.prenom"
      params = []
    } else {
      query = "SELECT * FROM patients WHERE site_id = ? ORDER BY nom, prenom"
      params = [req.utilisateur.site_id]
    }

    const [patients] = await connexionBD.execute(query, params)

    await enregistrerAudit("CONSULTATION_LISTE_PATIENTS", req.utilisateur.id, {
      nombre_patients: patients.length,
      role: req.utilisateur.role,
    })

    res.json(patients)
  } catch (erreur) {
    console.error("Erreur lors de la r√©cup√©ration des patients:", erreur)
    res.status(500).json({ erreur: "Erreur serveur" })
  }
})

// Cr√©er un nouveau patient
app.post("/api/patients", verifierToken, async (req, res) => {
  try {
    const { nom, prenom, age, telephone, adresse, antecedents } = req.body

    // Validation des donn√©es
    if (!nom || !prenom || !age) {
      return res.status(400).json({ erreur: "Nom, pr√©nom et √¢ge sont obligatoires" })
    }

    const [resultat] = await connexionBD.execute(
      `INSERT INTO patients (nom, prenom, age, telephone, adresse, antecedents, site_id, date_creation) 
       VALUES (?, ?, ?, ?, ?, ?, ?, NOW())`,
      [nom, prenom, age, telephone, adresse, antecedents, req.utilisateur.site_id],
    )

    await enregistrerAudit("CREATION_PATIENT", req.utilisateur.id, {
      patient_id: resultat.insertId,
      nom: nom,
      prenom: prenom,
    })

    res.status(201).json({
      message: "Patient cr√©√© avec succ√®s",
      id: resultat.insertId,
    })
  } catch (erreur) {
    console.error("Erreur lors de la cr√©ation du patient:", erreur)
    res.status(500).json({ erreur: "Erreur serveur" })
  }
})

// R√©cup√©rer un patient sp√©cifique
app.get("/api/patients/:id", verifierToken, async (req, res) => {
  try {
    let query, params

    if (req.utilisateur.role === "admin") {
      query = "SELECT * FROM patients WHERE id = ?"
      params = [req.params.id]
    } else {
      query = "SELECT * FROM patients WHERE id = ? AND site_id = ?"
      params = [req.params.id, req.utilisateur.site_id]
    }

    const [patients] = await connexionBD.execute(query, params)

    if (patients.length === 0) {
      return res.status(404).json({ erreur: "Patient non trouv√©" })
    }

    await enregistrerAudit("CONSULTATION_PATIENT", req.utilisateur.id, {
      patient_id: req.params.id,
    })

    res.json(patients[0])
  } catch (erreur) {
    console.error("Erreur lors de la r√©cup√©ration du patient:", erreur)
    res.status(500).json({ erreur: "Erreur serveur" })
  }
})

// ================================
// ROUTES CONSULTATIONS
// ================================

// Lister toutes les consultations
app.get("/api/consultations", verifierToken, async (req, res) => {
  try {
    let query, params

    if (req.utilisateur.role === "admin") {
      query = `SELECT c.*, 
                      p.nom as nom_patient, p.prenom as prenom_patient,
                      m.nom as nom_medecin, m.prenom as prenom_medecin,
                      s.nom as nom_site
               FROM consultations c 
               JOIN patients p ON c.patient_id = p.id 
               JOIN medecins m ON c.medecin_id = m.id
               JOIN sites s ON p.site_id = s.id
               ORDER BY c.date_consultation DESC`
      params = []
    } else {
      query = `SELECT c.*, 
                      p.nom as nom_patient, p.prenom as prenom_patient,
                      m.nom as nom_medecin, m.prenom as prenom_medecin
               FROM consultations c 
               JOIN patients p ON c.patient_id = p.id 
               JOIN medecins m ON c.medecin_id = m.id
               WHERE p.site_id = ?
               ORDER BY c.date_consultation DESC`
      params = [req.utilisateur.site_id]
    }

    const [consultations] = await connexionBD.execute(query, params)

    await enregistrerAudit("CONSULTATION_LISTE_CONSULTATIONS", req.utilisateur.id, {
      nombre_consultations: consultations.length,
      role: req.utilisateur.role,
    })

    res.json(consultations)
  } catch (erreur) {
    console.error("Erreur lors de la r√©cup√©ration des consultations:", erreur)
    res.status(500).json({ erreur: "Erreur serveur" })
  }
})

// Cr√©er une nouvelle consultation
app.post("/api/consultations", verifierToken, async (req, res) => {
  try {
    const { patient_id, diagnostic, notes, traitement } = req.body

    // Validation des donn√©es
    if (!patient_id || !diagnostic) {
      return res.status(400).json({ erreur: "Patient et diagnostic sont obligatoires" })
    }

    // V√©rifier que le patient existe et est accessible
    let query, params
    if (req.utilisateur.role === "admin") {
      query = "SELECT * FROM patients WHERE id = ?"
      params = [patient_id]
    } else {
      query = "SELECT * FROM patients WHERE id = ? AND site_id = ?"
      params = [patient_id, req.utilisateur.site_id]
    }

    const [patients] = await connexionBD.execute(query, params)

    if (patients.length === 0) {
      return res.status(403).json({ erreur: "Acc√®s non autoris√© √† ce patient" })
    }

    const [resultat] = await connexionBD.execute(
      `INSERT INTO consultations (patient_id, medecin_id, diagnostic, notes, traitement, date_consultation) 
       VALUES (?, ?, ?, ?, ?, NOW())`,
      [patient_id, req.utilisateur.id, diagnostic, notes, traitement],
    )

    await enregistrerAudit("CREATION_CONSULTATION", req.utilisateur.id, {
      consultation_id: resultat.insertId,
      patient_id: patient_id,
      diagnostic: diagnostic,
    })

    res.status(201).json({
      message: "Consultation enregistr√©e avec succ√®s",
      id: resultat.insertId,
    })
  } catch (erreur) {
    console.error("Erreur lors de la cr√©ation de la consultation:", erreur)
    res.status(500).json({ erreur: "Erreur serveur" })
  }
})

// R√©cup√©rer les consultations d'un patient sp√©cifique
app.get("/api/patients/:id/consultations", verifierToken, async (req, res) => {
  try {
    let query, params

    if (req.utilisateur.role === "admin") {
      query = `SELECT c.*, m.nom as nom_medecin, m.prenom as prenom_medecin 
               FROM consultations c 
               JOIN medecins m ON c.medecin_id = m.id 
               WHERE c.patient_id = ?
               ORDER BY c.date_consultation DESC`
      params = [req.params.id]
    } else {
      query = `SELECT c.*, m.nom as nom_medecin, m.prenom as prenom_medecin 
               FROM consultations c 
               JOIN medecins m ON c.medecin_id = m.id 
               JOIN patients p ON c.patient_id = p.id 
               WHERE c.patient_id = ? AND p.site_id = ?
               ORDER BY c.date_consultation DESC`
      params = [req.params.id, req.utilisateur.site_id]
    }

    const [consultations] = await connexionBD.execute(query, params)

    await enregistrerAudit("CONSULTATION_HISTORIQUE", req.utilisateur.id, {
      patient_id: req.params.id,
      nombre_consultations: consultations.length,
    })

    res.json(consultations)
  } catch (erreur) {
    console.error("Erreur lors de la r√©cup√©ration des consultations:", erreur)
    res.status(500).json({ erreur: "Erreur serveur" })
  }
})

// ================================
// ROUTES PRESCRIPTIONS
// ================================

// Cr√©er une prescription
app.post("/api/prescriptions", verifierToken, async (req, res) => {
  try {
    const { consultation_id, medicaments, posologie, duree } = req.body

    // Validation des donn√©es
    if (!consultation_id || !medicaments) {
      return res.status(400).json({ erreur: "Consultation et m√©dicaments sont obligatoires" })
    }

    const [resultat] = await connexionBD.execute(
      `INSERT INTO prescriptions (consultation_id, medicaments, posologie, duree, date_prescription) 
       VALUES (?, ?, ?, ?, NOW())`,
      [consultation_id, medicaments, posologie, duree],
    )

    await enregistrerAudit("CREATION_PRESCRIPTION", req.utilisateur.id, {
      prescription_id: resultat.insertId,
      consultation_id: consultation_id,
      medicaments: medicaments,
    })

    res.status(201).json({
      message: "Prescription cr√©√©e avec succ√®s",
      id: resultat.insertId,
    })
  } catch (erreur) {
    console.error("Erreur lors de la cr√©ation de la prescription:", erreur)
    res.status(500).json({ erreur: "Erreur serveur" })
  }
})

// ================================
// ROUTES AUDIT (ADMIN SEULEMENT)
// ================================

// R√©cup√©rer les logs d'audit - ADMIN SEULEMENT
app.get("/api/audit", verifierToken, verifierAdmin, async (req, res) => {
  try {
    const [logs] = await connexionBD.execute(`
      SELECT a.*, m.nom as nom_medecin, m.prenom as prenom_medecin 
      FROM audit a 
      LEFT JOIN medecins m ON a.utilisateur_id = m.id 
      ORDER BY a.date_action DESC 
      LIMIT 100
    `)

    await enregistrerAudit("CONSULTATION_AUDIT", req.utilisateur.id, {
      nombre_logs: logs.length,
    })

    res.json(logs)
  } catch (erreur) {
    console.error("Erreur lors de la r√©cup√©ration des logs d'audit:", erreur)
    res.status(500).json({ erreur: "Erreur interne du serveur" })
  }
})

// ================================
// ROUTES STATIQUES
// ================================

// Route pour servir le frontend
app.get("/", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"))
})

// Route de test pour v√©rifier que le serveur fonctionne
app.get("/api/test", (req, res) => {
  res.json({
    message: "Serveur SenSant√© op√©rationnel",
    timestamp: new Date().toISOString(),
  })
})

// ================================
// GESTION DES ERREURS
// ================================

// Middleware de gestion des erreurs 404
app.use((req, res) => {
  console.log(`‚ùå Route non trouv√©e: ${req.method} ${req.url}`)
  res.status(404).json({ erreur: "Route non trouv√©e" })
})

// Middleware de gestion des erreurs globales
app.use((err, req, res, next) => {
  console.error("Erreur serveur:", err)
  res.status(500).json({ erreur: "Erreur interne du serveur" })
})

// ================================
// D√âMARRAGE DU SERVEUR
// ================================

async function demarrerServeur() {
  try {
    // Connexion √† la base de donn√©es
    await connecterBD()

    // D√©marrage du serveur HTTP
    app.listen(PORT, () => {
      console.log(`üöÄ Serveur SenSant√© d√©marr√© sur http://localhost:${PORT}`)
      console.log(`üìä Dashboard: http://localhost:${PORT}`)
      console.log(`üîß API Test: http://localhost:${PORT}/api/test`)
      console.log(`üìù Comptes disponibles:`)
      console.log(`   üë®‚Äçüíº Admin: admin@sensante.sn / admin123`)
      console.log(`   üë®‚Äç‚öïÔ∏è M√©decin: amadou.diop@sensante.sn / motdepasse123`)
      console.log(`   üë®‚Äç‚öïÔ∏è M√©decin: fatou.ndiaye@sensante.sn / motdepasse123`)
    })
  } catch (erreur) {
    console.error("‚ùå Erreur lors du d√©marrage du serveur:", erreur)
    process.exit(1)
  }
}

// Gestion propre de l'arr√™t du serveur
process.on("SIGINT", async () => {
  console.log("\nüõë Arr√™t du serveur en cours...")
  if (connexionBD) {
    await connexionBD.end()
    console.log("‚úÖ Connexion MySQL ferm√©e")
  }
  process.exit(0)
})

// D√©marrer l'application
const demarrarServeur = demarrerServeur
demarrarServeur()
